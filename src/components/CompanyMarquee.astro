---
import type { Company } from "@/types/company";
import IconGitCommit from "@/assets/icons/git-commit.svg";

type Direction = "left" | "right";

interface Props {
	companies: Company[];
	label: string;
	duration?: number;
	direction?: Direction;
}

const { companies, label, duration = 45, direction = "left" } = Astro.props;
const { t } = Astro.locals;
---

<div
	class="marquee-container"
	aria-label={label}
	style={`--marquee-duration: ${duration}s`}
>
	<!-- Visually hidden list for screen readers -->
	<ul class="sr-only">
		{
			companies.map((company) => (
				<li>
					<a
						href={company.url}
						target="_blank"
						rel="noopener noreferrer"
						referrerpolicy="strict-origin-when-cross-origin"
					>
						{company.name}
						<span class="sr-only">{t("a11y.opensInNewTab")}</span>
					</a>
				</li>
			))
		}
	</ul>

	<!-- Visual marquee (hidden from screen readers) -->
	<div
		class:list={[
			"marquee-track",
			{ "marquee-track--reverse": direction === "right" },
		]}
		aria-hidden="true"
	>
		{
			[0, 1].map((iteration) => (
				<div class="marquee-content">
					{companies.map((company, index) => (
						<>
							{index > 0 && <IconGitCommit class="marquee-separator" />}
							<a
								href={company.url}
								target="_blank"
								rel="noopener noreferrer"
								referrerpolicy="strict-origin-when-cross-origin"
								tabindex="-1"
								class="marquee-link"
							>
								<img
									src={company.logo}
									alt={`${company.name} logo`}
									class="marquee-logo marquee-logo--light"
									width={company.width}
									height="28"
									loading={iteration === 0 ? "eager" : "lazy"}
									decoding="async"
								/>
								<img
									src={company.logoDark}
									alt=""
									class="marquee-logo marquee-logo--dark"
									width={company.width}
									height="28"
									loading="lazy"
									decoding="async"
								/>
							</a>
						</>
					))}
					<IconGitCommit class="marquee-separator" />
				</div>
			))
		}
	</div>
</div>

<style>
	.marquee-container {
		position: relative;
		overflow: hidden;
		-webkit-mask-image: linear-gradient(
			to right,
			transparent,
			black 5%,
			black 95%,
			transparent
		);
		mask-image: linear-gradient(
			to right,
			transparent,
			black 5%,
			black 95%,
			transparent
		);
	}

	.marquee-track {
		display: flex;
		width: max-content;
		animation: marquee var(--marquee-duration) linear infinite;
		transform: translateZ(0);
		will-change: transform;
	}

	.marquee-track--reverse {
		animation-direction: reverse;
	}

	.marquee-container:hover .marquee-track {
		animation-play-state: paused;
	}

	.marquee-content {
		display: flex;
		align-items: center;
		gap: 2rem;
		padding-right: 2rem;
	}

	.marquee-link {
		display: block;
		opacity: 0.7;
		transition: opacity 0.2s ease;
	}

	.marquee-link:hover {
		opacity: 1;
	}

	.marquee-logo {
		height: 1.75rem;
		width: auto;
	}

	.marquee-logo--light {
		display: block;
	}

	.marquee-logo--dark {
		display: none;
	}

	:global([data-theme="dark"]) .marquee-logo--light {
		display: none;
	}

	:global([data-theme="dark"]) .marquee-logo--dark {
		display: block;
	}

	.marquee-separator {
		color: oklch(78% 0.06 270);
		flex-shrink: 0;
	}

	@keyframes marquee {
		from {
			transform: translateX(0);
		}
		to {
			transform: translateX(-50%);
		}
	}

	.marquee-track.is-dragging {
		animation-play-state: paused;
		cursor: grabbing;
	}

	@media (prefers-reduced-motion: reduce) {
		.marquee-track {
			animation: none;
		}
	}
</style>

<script>
	function initMarqueeDrag(): void {
		document
			.querySelectorAll<HTMLElement>(".marquee-container")
			.forEach((container) => {
				if (container.dataset.dragInit) return;
				container.dataset.dragInit = "true";

				const track = container.querySelector<HTMLElement>(".marquee-track");
				if (!track) return;

				const isReverse = track.classList.contains("marquee-track--reverse");
				let isDragging = false;
				let startX = 0;
				let currentOffset = 0;

				function getTranslateX(): number {
					const matrix = new DOMMatrix(getComputedStyle(track!).transform);
					return matrix.m41;
				}

				function onStart(x: number): void {
					isDragging = true;
					startX = x;
					currentOffset = getTranslateX();
					track!.classList.add("is-dragging");
					track!.style.transform = `translateX(${currentOffset}px)`;
				}

				function onMove(x: number): void {
					if (!isDragging) return;
					const delta = x - startX;
					const contentWidth = track!.scrollWidth / 2;
					let newOffset = currentOffset + delta;

					// Wrap around seamlessly
					if (newOffset > 0) newOffset -= contentWidth;
					if (newOffset < -contentWidth) newOffset += contentWidth;

					track!.style.transform = `translateX(${newOffset}px)`;
				}

				function onEnd(): void {
					if (!isDragging) return;
					isDragging = false;

					// Calculate where we are as a fraction of the animation cycle.
					// The animation goes from 0 to -50% (half the total scrollWidth).
					const contentWidth = track!.scrollWidth / 2;
					const finalX = getTranslateX();

					// Normalize to 0..1 progress through the animation
					let progress = -finalX / contentWidth;
					if (isReverse) progress = 1 - progress;
					progress = ((progress % 1) + 1) % 1;

					// Resume animation from the drag position using negative delay
					const duration = parseFloat(
						getComputedStyle(container).getPropertyValue("--marquee-duration"),
					);
					track!.style.transform = "";
					track!.style.animationDelay = `-${progress * duration}s`;
					track!.classList.remove("is-dragging");
				}

				container.addEventListener(
					"touchstart",
					(e) => onStart(e.touches[0].clientX),
					{ passive: true },
				);
				container.addEventListener(
					"touchmove",
					(e) => onMove(e.touches[0].clientX),
					{ passive: true },
				);
				container.addEventListener("touchend", onEnd);
			});
	}

	initMarqueeDrag();
	document.addEventListener("astro:after-swap", initMarqueeDrag);
</script>
