---
import Card from "@/components/Card.astro";
import IconClose from "@/components/icons/IconClose.astro";
import ViewMoreButton from "@/components/ViewMoreButton.astro";

type Category = "frameworks" | "languages" | "tools";

interface Technology {
	name: string;
	icon: string;
	experience: number;
	category: Category;
}

interface Props {
	technologies: Technology[];
	initialVisible?: number;
}

const { technologies, initialVisible = 9 } = Astro.props;

const categories: { id: Category; label: string }[] = [
	{ id: "frameworks", label: "Frameworks" },
	{ id: "languages", label: "Languages" },
	{ id: "tools", label: "Tools" },
];

const formatExperience = (years: number) => {
	return years === 1
		? "+1 year of experience"
		: `+${years} years of experience`;
};
---

<Card>
	<div
		class="flex flex-col gap-6"
		data-stack-section
		data-initial-visible={initialVisible}
	>
		<header
			class="flex flex-col items-start gap-4 sm:flex-row sm:items-center sm:justify-between"
		>
			<h2 class="text-2xl font-semibold text-title">Stack</h2>
			<div class="flex gap-2 items-center">
				<button
					type="button"
					class="stack-clear hidden order-1 sm:order-first size-8 items-center justify-center border border-subtitle rounded-full bg-transparent text-subtitle cursor-pointer transition-all hover:border-title hover:text-title"
					aria-label="Clear filters"
				>
					<IconClose class="size-4" />
				</button>
				{
					categories.map(({ id, label }) => (
						<button
							type="button"
							class="stack-filter py-1.5 px-4 border border-subtitle rounded-full bg-transparent text-subtitle text-sm cursor-pointer transition-all hover:border-title hover:text-title"
							data-category={id}
							aria-pressed="false"
						>
							{label}
						</button>
					))
				}
			</div>
		</header>

		<ul
			class="stack-grid grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 list-none p-0 m-0"
			role="list"
		>
			{
				technologies.map((tech, index) => (
					<li
						class:list={[
							"stack-item flex items-center gap-3 p-2",
							{ hidden: index >= initialVisible },
						]}
						data-category={tech.category}
					>
						<img
							src={tech.icon}
							alt={`${tech.name} logo`}
							class="size-12 object-contain"
							width="48"
							height="48"
						/>
						<div class="flex flex-col gap-0.5">
							<span class="text-lg font-medium text-title">{tech.name}</span>
							<span class="text-sm text-subtitle">
								{formatExperience(tech.experience)}
							</span>
						</div>
					</li>
				))
			}
		</ul>

		<ViewMoreButton class="stack-view-more" />
	</div>
</Card>

<style>
	.stack-filter[aria-pressed="true"] {
		border-color: var(--color-title);
		background: var(--color-title);
		color: var(--color-card);
	}

	.stack-clear {
		display: flex;
		opacity: 1;
		transform: rotate(0deg) scale(1);
	}

	.stack-clear:hover {
		transform: rotate(90deg) scale(1.1);
	}

	.stack-clear.hidden {
		opacity: 0;
		transform: scale(0.5);
		pointer-events: none;
	}

	.stack-clear.appearing {
		animation: clear-appear 0.25s ease forwards;
	}

	.stack-clear.disappearing {
		animation: clear-disappear 0.25s ease forwards;
	}

	@keyframes clear-appear {
		from {
			opacity: 0;
			transform: rotate(-90deg) scale(0.5);
		}
		to {
			opacity: 1;
			transform: rotate(0deg) scale(1);
		}
	}

	@keyframes clear-disappear {
		from {
			opacity: 1;
			transform: rotate(0deg) scale(1);
		}
		to {
			opacity: 0;
			transform: rotate(90deg) scale(0.5);
		}
	}

	.stack-item.hidden,
	.stack-item.filtered {
		display: none;
	}
</style>

<script>
	function initStackSection() {
		const section = document.querySelector(
			"[data-stack-section]",
		) as HTMLElement;
		if (!section) return;

		const initialVisible = parseInt(section.dataset.initialVisible || "9", 10);
		const filters =
			section.querySelectorAll<HTMLButtonElement>(".stack-filter");
		const clearBtn = section.querySelector<HTMLButtonElement>(".stack-clear");
		const items = section.querySelectorAll<HTMLLIElement>(".stack-item");
		const viewMoreBtn =
			section.querySelector<HTMLButtonElement>(".stack-view-more");
		const viewMoreText = viewMoreBtn?.querySelector<HTMLSpanElement>(
			".view-more-btn-text",
		);

		let activeCategories = new Set<string>();
		let isExpanded = false;

		function updateVisibility() {
			let visibleCount = 0;
			let totalVisible = 0;

			items.forEach((item) => {
				const category = item.dataset.category;
				const matchesFilter =
					activeCategories.size === 0 || activeCategories.has(category || "");

				if (!matchesFilter) {
					item.classList.remove("hidden");
					item.classList.add("filtered");
				} else {
					item.classList.remove("filtered");
					totalVisible++;
					visibleCount++;
					const shouldHide = !isExpanded && visibleCount > initialVisible;

					if (shouldHide) {
						item.classList.add("hidden");
					} else {
						item.classList.remove("hidden");
					}
				}
			});

			// Update clear button
			if (clearBtn) {
				const shouldShow = activeCategories.size > 0;
				const isCurrentlyHidden = clearBtn.classList.contains("hidden");

				if (shouldShow && isCurrentlyHidden) {
					clearBtn.classList.remove("hidden", "disappearing");
					clearBtn.classList.add("appearing");
				} else if (!shouldShow && !isCurrentlyHidden) {
					clearBtn.classList.remove("appearing");
					clearBtn.classList.add("disappearing");
					clearBtn.addEventListener(
						"animationend",
						() => {
							if (clearBtn.classList.contains("disappearing")) {
								clearBtn.classList.add("hidden");
							}
						},
						{ once: true },
					);
				}
			}

			// Update view more button
			if (viewMoreBtn && viewMoreText) {
				const hasMore = totalVisible > initialVisible;
				viewMoreBtn.classList.toggle("hidden", !hasMore);
				viewMoreText.textContent = isExpanded
					? viewMoreBtn.dataset.expandedText || "View Less"
					: viewMoreBtn.dataset.collapsedText || "View More";
				viewMoreBtn.classList.toggle("expanded", isExpanded);
			}
		}

		filters.forEach((filter) => {
			filter.addEventListener("click", () => {
				const category = filter.dataset.category;
				if (!category) return;

				const isPressed = filter.getAttribute("aria-pressed") === "true";
				filter.setAttribute("aria-pressed", String(!isPressed));

				if (isPressed) {
					activeCategories.delete(category);
				} else {
					activeCategories.add(category);
				}

				updateVisibility();
			});
		});

		clearBtn?.addEventListener("click", () => {
			activeCategories.clear();
			filters.forEach((filter) => filter.setAttribute("aria-pressed", "false"));
			updateVisibility();
		});

		viewMoreBtn?.addEventListener("click", () => {
			isExpanded = !isExpanded;
			updateVisibility();
		});

		// Initial render
		updateVisibility();
	}

	// Run on initial load
	initStackSection();

	// Re-run on Astro page transitions
	document.addEventListener("astro:after-swap", initStackSection);
</script>
