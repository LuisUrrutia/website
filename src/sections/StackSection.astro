---
import Card from "@/components/Card.astro";
import ClearFilterButton from "@/components/ClearFilterButton.astro";
import FilterChip from "@/components/FilterChip.astro";
import TechItem from "@/components/TechItem.astro";
import ViewMoreButton from "@/components/ViewMoreButton.astro";

type Category = "frameworks" | "languages" | "tools";

interface ThemedIcon {
	light: string;
	dark: string;
}

type ColorMode = "keep" | "auto";

interface Technology {
	name: string;
	icon: string | ThemedIcon;
	colorMode?: ColorMode;
	experience: number;
	category: Category;
}

interface Props {
	technologies: Technology[];
	initialVisible?: number;
}

const { technologies, initialVisible = 9 } = Astro.props;

const categories: { id: Category; label: string }[] = [
	{ id: "frameworks", label: "Frameworks" },
	{ id: "languages", label: "Languages" },
	{ id: "tools", label: "Tools" },
];

// Pre-compute indices by category at build time
const indicesByCategory = technologies.reduce(
	(acc, tech, index) => {
		acc[tech.category] = acc[tech.category] || [];
		acc[tech.category].push(index);
		return acc;
	},
	{} as Record<Category, number[]>,
);
---

<Card>
	<div
		class="stack-section flex flex-col gap-6"
		data-initial-visible={initialVisible}
		data-indices={JSON.stringify(indicesByCategory)}
	>
		<header
			class="flex flex-col items-start gap-4 sm:flex-row sm:items-center sm:justify-between"
		>
			<h2 class="text-title text-2xl font-semibold">Stack</h2>
			<div data-stack-filters class="flex items-center gap-2">
				<ClearFilterButton data-stack-clear class="order-1 sm:order-first" />
				{
					categories.map(({ id, label }) => (
						<FilterChip data-stack-filter={id} category={id} label={label} />
					))
				}
			</div>
		</header>

		<ul
			class="stack-grid m-0 grid list-none grid-cols-1 p-0 sm:grid-cols-2 md:grid-cols-3"
			role="list"
		>
			{
				technologies.map((tech, index) => (
					<li
						data-stack-item
						data-hidden={index >= initialVisible ? "" : undefined}
					>
						<TechItem
							name={tech.name}
							icon={tech.icon}
							colorMode={tech.colorMode}
							experience={tech.experience}
						/>
					</li>
				))
			}
		</ul>

		<ViewMoreButton
			data-stack-view-more
			class:list={[{ hidden: technologies.length <= initialVisible }]}
		/>

		<div
			data-stack-status
			class="sr-only"
			aria-live="polite"
			aria-atomic="true"
		>
		</div>
	</div>
</Card>

<style>
	[data-stack-item][data-hidden] {
		display: none;
	}
</style>

<script>
	import { animateVisibility } from "@/lib/dom/animations";

	function createViewMoreUpdater(btn: HTMLButtonElement) {
		const textEl = btn.querySelector<HTMLSpanElement>("[data-view-more-text]");
		const expandedText = btn.dataset.expandedText || "View Less";
		const collapsedText = btn.dataset.collapsedText || "View More";

		return (hasMore: boolean, isExpanded: boolean) => {
			btn.classList.toggle("hidden", !hasMore);
			btn.classList.toggle("expanded", isExpanded);

			if (textEl) {
				textEl.textContent = isExpanded ? expandedText : collapsedText;
			}
		};
	}

	function initStackSection(): void {
		const section = document.querySelector<HTMLElement>(".stack-section");
		if (!section) return;

		const filtersContainer = section.querySelector<HTMLElement>(
			"[data-stack-filters]",
		);
		const filters = section.querySelectorAll<HTMLButtonElement>(
			"[data-stack-filter]",
		);
		const clearBtn =
			section.querySelector<HTMLButtonElement>("[data-stack-clear]");
		const viewMoreBtn = section.querySelector<HTMLButtonElement>(
			"[data-stack-view-more]",
		);
		const statusEl = section.querySelector<HTMLElement>("[data-stack-status]");

		// Elements array for O(1) index access
		const elements = Array.from(
			section.querySelectorAll<HTMLElement>("[data-stack-item]"),
		);

		// Read pre-computed data from Astro (built at compile time)
		const initialVisible = Number(section.dataset.initialVisible) || 9;
		const totalItems = elements.length;
		const indicesByCategory: Record<string, number[]> = JSON.parse(
			section.dataset.indices || "{}",
		);

		// Build arrays from pre-computed counts (faster than parsing comma-separated strings)
		const allIndices = Array.from({ length: totalItems }, (_, i) => i);
		const visibleIndices = new Set(
			Array.from({ length: Math.min(initialVisible, totalItems) }, (_, i) => i),
		);

		// Create cached updater for view more button
		const updateViewMore = viewMoreBtn
			? createViewMoreUpdater(viewMoreBtn)
			: null;

		// State
		const activeCategories = new Set<string>();
		let isExpanded = false;

		function update(): void {
			const hasFilter = activeCategories.size > 0;

			// Get matching indices - no iteration when no filter
			let matchingIndices: number[];
			if (hasFilter) {
				matchingIndices = [];
				for (const cat of activeCategories) {
					const indices = indicesByCategory[cat];
					if (indices) {
						for (const i of indices) matchingIndices.push(i);
					}
				}
				matchingIndices.sort((a, b) => a - b);
			} else {
				matchingIndices = allIndices;
			}

			const totalMatching = matchingIndices.length;
			const limit = isExpanded
				? totalMatching
				: Math.min(initialVisible, totalMatching);

			// Build next visible set from slice (avoids iteration for limit check)
			const nextVisible = new Set(matchingIndices.slice(0, limit));

			// Diff: hide items no longer visible
			for (const i of visibleIndices) {
				if (!nextVisible.has(i)) {
					elements[i].dataset.hidden = "";
				}
			}

			// Diff: show newly visible items
			for (const i of nextVisible) {
				if (!visibleIndices.has(i)) {
					delete elements[i].dataset.hidden;
				}
			}

			// Update state in place
			visibleIndices.clear();
			for (const i of nextVisible) visibleIndices.add(i);

			if (clearBtn) {
				animateVisibility(clearBtn, hasFilter);
			}

			if (updateViewMore) {
				updateViewMore(totalMatching > initialVisible, isExpanded);
			}

			// Announce to screen readers
			if (statusEl) {
				const showing = nextVisible.size;
				statusEl.textContent = `Showing ${showing} of ${totalMatching} items`;
			}
		}

		// Event delegation for filter chips
		filtersContainer?.addEventListener("click", (e) => {
			const filterBtn = (e.target as HTMLElement).closest<HTMLButtonElement>(
				"[data-stack-filter]",
			);
			if (!filterBtn) return;

			const category = filterBtn.dataset.stackFilter;
			if (!category) return;

			const isPressed = filterBtn.getAttribute("aria-pressed") === "true";
			filterBtn.setAttribute("aria-pressed", String(!isPressed));

			if (isPressed) {
				activeCategories.delete(category);
			} else {
				activeCategories.add(category);
			}

			update();
		});

		// Clear button
		clearBtn?.addEventListener("click", () => {
			activeCategories.clear();
			filters.forEach((f) => f.setAttribute("aria-pressed", "false"));
			update();
		});

		// View more button
		viewMoreBtn?.addEventListener("click", () => {
			isExpanded = !isExpanded;
			update();
		});
	}

	initStackSection();
	document.addEventListener("astro:after-swap", initStackSection);
</script>
