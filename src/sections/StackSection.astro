---
import type { Technology, TechnologyCategory } from "@/types/technology";
import Card from "@/components/Card.astro";
import ClearFilterButton from "@/components/ClearFilterButton.astro";
import FilterChip from "@/components/FilterChip.astro";
import TechItem from "@/components/TechItem.astro";
import ExpandButton from "@/components/ExpandButton.astro";

interface Props {
	technologies: Technology[];
	initialVisible?: number;
}

const { technologies, initialVisible = 9 } = Astro.props;

const categories: { id: TechnologyCategory; label: string }[] = [
	{ id: "frameworks", label: "Frameworks" },
	{ id: "languages", label: "Languages" },
	{ id: "tools", label: "Tools" },
];

// Pre-compute indices by category at build time
const indicesByCategory = technologies.reduce(
	(acc, tech, index) => {
		acc[tech.category] = acc[tech.category] || [];
		acc[tech.category].push(index);
		return acc;
	},
	{} as Record<Category, number[]>,
);
---

<Card>
	<div
		class="stack-section flex flex-col gap-6"
		data-initial-visible={initialVisible}
		data-indices={JSON.stringify(indicesByCategory)}
	>
		<header
			class="flex flex-col items-start gap-4 sm:flex-row sm:items-center sm:justify-between"
		>
			<h2 class="text-title text-2xl font-semibold">Stack</h2>
			<div class="stack-filters flex items-center gap-2">
				<ClearFilterButton class="stack-clear order-1 sm:order-first" />
				{
					categories.map(({ id, label }) => (
						<FilterChip
							class="stack-filter"
							data-category={id}
							category={id}
							label={label}
						/>
					))
				}
			</div>
		</header>

		<ul
			class="stack-grid m-0 grid list-none grid-cols-1 gap-4 p-0 sm:grid-cols-2 md:grid-cols-3"
			role="list"
		>
			{
				technologies.map((tech, index) => (
					<li class:list={["stack-item", { hidden: index >= initialVisible }]}>
						<TechItem
							name={tech.name}
							icon={tech.icon}
							colorMode={tech.colorMode}
							experience={tech.experience}
						/>
					</li>
				))
			}
		</ul>

		<ExpandButton
			class:list={[
				"stack-expand-btn",
				{ hidden: technologies.length <= initialVisible },
			]}
		/>

		<div class="stack-status sr-only" aria-live="polite" aria-atomic="true">
		</div>
	</div>
</Card>

<script>
	function initStackSections(): void {
		document
			.querySelectorAll<HTMLElement>(".stack-section")
			.forEach((section) => {
				if (section.dataset.init) return;
				section.dataset.init = "true";

				const filtersContainer =
					section.querySelector<HTMLElement>(".stack-filters");
				const filters =
					section.querySelectorAll<HTMLButtonElement>(".stack-filter");
				const clearBtn =
					section.querySelector<HTMLButtonElement>(".stack-clear");
				const expandBtn =
					section.querySelector<HTMLButtonElement>(".stack-expand-btn");
				const statusEl = section.querySelector<HTMLElement>(".stack-status");

				// Elements array for O(1) index access
				const elements = Array.from(
					section.querySelectorAll<HTMLElement>(".stack-item"),
				);

				// Read pre-computed data from Astro (built at compile time)
				const initialVisible = Number(section.dataset.initialVisible) || 9;
				const totalItems = elements.length;
				const indicesByCategory: Record<string, number[]> = JSON.parse(
					section.dataset.indices || "{}",
				);

				// Build arrays from pre-computed counts
				const allIndices = Array.from({ length: totalItems }, (_, i) => i);
				const visibleIndices = new Set(
					Array.from(
						{ length: Math.min(initialVisible, totalItems) },
						(_, i) => i,
					),
				);

				// State
				const activeCategories = new Set<string>();
				let isExpanded = false;

				function update(): void {
					const hasFilter = activeCategories.size > 0;

					// Get matching indices - no iteration when no filter
					let matchingIndices: number[];
					if (hasFilter) {
						matchingIndices = [];
						for (const cat of activeCategories) {
							const indices = indicesByCategory[cat];
							if (indices) {
								for (const i of indices) matchingIndices.push(i);
							}
						}
						matchingIndices.sort((a, b) => a - b);
					} else {
						matchingIndices = allIndices;
					}

					const totalMatching = matchingIndices.length;
					const limit = isExpanded
						? totalMatching
						: Math.min(initialVisible, totalMatching);

					// Build next visible set from slice
					const nextVisible = new Set(matchingIndices.slice(0, limit));

					// Diff: hide items no longer visible
					for (const i of visibleIndices) {
						if (!nextVisible.has(i)) {
							elements[i].classList.add("hidden");
						}
					}

					// Diff: show newly visible items
					for (const i of nextVisible) {
						if (!visibleIndices.has(i)) {
							elements[i].classList.remove("hidden");
						}
					}

					// Update state in place
					visibleIndices.clear();
					for (const i of nextVisible) visibleIndices.add(i);

					if (clearBtn) {
						clearBtn.setAttribute("aria-hidden", String(!hasFilter));
					}

					if (expandBtn) {
						expandBtn.classList.toggle(
							"hidden",
							totalMatching <= initialVisible,
						);
					}

					// Announce to screen readers
					if (statusEl) {
						const showing = nextVisible.size;
						statusEl.textContent = `Showing ${showing} of ${totalMatching} items`;
					}
				}

				// Event delegation for filter chips
				filtersContainer?.addEventListener("click", (e) => {
					const filterBtn = (
						e.target as HTMLElement
					).closest<HTMLButtonElement>(".stack-filter");
					if (!filterBtn) return;

					const category = filterBtn.dataset.category;
					if (!category) return;

					const isPressed = filterBtn.getAttribute("aria-pressed") === "true";
					filterBtn.setAttribute("aria-pressed", String(!isPressed));

					if (isPressed) {
						activeCategories.delete(category);
					} else {
						activeCategories.add(category);
					}

					update();
				});

				// Clear button
				clearBtn?.addEventListener("click", () => {
					activeCategories.clear();
					filters.forEach((f) => f.setAttribute("aria-pressed", "false"));
					update();
				});

				// Expand button
				expandBtn?.addEventListener("expand-toggle", ((
					e: CustomEvent<{ expanded: boolean }>,
				) => {
					isExpanded = e.detail.expanded;
					update();
				}) as EventListener);
			});
	}

	initStackSections();
	document.addEventListener("astro:after-swap", initStackSections);
</script>
