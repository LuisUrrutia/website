---
import Card from "@/components/Card.astro";
import ClearFilterButton from "@/components/ClearFilterButton.astro";
import FilterChip from "@/components/FilterChip.astro";
import TechItem from "@/components/TechItem.astro";
import ViewMoreButton from "@/components/ViewMoreButton.astro";

type Category = "frameworks" | "languages" | "tools";

interface Technology {
	name: string;
	icon: string;
	experience: number;
	category: Category;
}

interface Props {
	technologies: Technology[];
	initialVisible?: number;
}

const { technologies, initialVisible = 9 } = Astro.props;

const categories: { id: Category; label: string }[] = [
	{ id: "frameworks", label: "Frameworks" },
	{ id: "languages", label: "Languages" },
	{ id: "tools", label: "Tools" },
];

// Pre-compute indices by category at build time
const indicesByCategory = technologies.reduce(
	(acc, tech, index) => {
		acc[tech.category] = acc[tech.category] || [];
		acc[tech.category].push(index);
		return acc;
	},
	{} as Record<Category, number[]>,
);
---

<Card>
	<div
		class="stack-section flex flex-col gap-6"
		data-initial-visible={initialVisible}
		data-total-items={technologies.length}
		data-indices={JSON.stringify(indicesByCategory)}
	>
		<header
			class="flex flex-col items-start gap-4 sm:flex-row sm:items-center sm:justify-between"
		>
			<h2 class="text-2xl font-semibold text-title">Stack</h2>
			<div data-stack-filters class="flex gap-2 items-center">
				<ClearFilterButton data-stack-clear class="order-1 sm:order-first" />
				{
					categories.map(({ id, label }) => (
						<FilterChip data-stack-filter={id} category={id} label={label} />
					))
				}
			</div>
		</header>

		<ul
			class="stack-grid grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 list-none p-0 m-0"
			role="list"
		>
			{
				technologies.map((tech, index) => (
					<li
						data-stack-item
						data-hidden={index >= initialVisible ? "" : undefined}
					>
						<TechItem
							name={tech.name}
							icon={tech.icon}
							experience={tech.experience}
						/>
					</li>
				))
			}
		</ul>

		<ViewMoreButton data-stack-view-more />
	</div>
</Card>

<style>
	[data-stack-item][data-hidden] {
		display: none;
	}
</style>

<script>
	function animateClearButton(btn: HTMLButtonElement, show: boolean): void {
		const isHidden = btn.classList.contains("hidden");

		if (show && isHidden) {
			btn.classList.remove("hidden", "disappearing");
			btn.classList.add("appearing");
		} else if (!show && !isHidden) {
			btn.classList.remove("appearing");
			btn.classList.add("disappearing");
			btn.addEventListener(
				"animationend",
				() =>
					btn.classList.contains("disappearing") && btn.classList.add("hidden"),
				{ once: true },
			);
		}
	}

	function updateViewMoreButton(
		btn: HTMLButtonElement,
		hasMore: boolean,
		isExpanded: boolean,
	): void {
		const textEl = btn.querySelector<HTMLSpanElement>("[data-view-more-text]");

		btn.classList.toggle("hidden", !hasMore);
		btn.classList.toggle("expanded", isExpanded);

		if (textEl) {
			textEl.textContent = isExpanded
				? btn.dataset.expandedText || "View Less"
				: btn.dataset.collapsedText || "View More";
		}
	}

	function initStackSection(): void {
		const section = document.querySelector<HTMLElement>(".stack-section");
		if (!section) return;

		const filtersContainer = section.querySelector<HTMLElement>(
			"[data-stack-filters]",
		);
		const filters = section.querySelectorAll<HTMLButtonElement>(
			"[data-stack-filter]",
		);
		const clearBtn =
			section.querySelector<HTMLButtonElement>("[data-stack-clear]");
		const viewMoreBtn = section.querySelector<HTMLButtonElement>(
			"[data-stack-view-more]",
		);

		// Elements array for O(1) index access
		const elements = Array.from(
			section.querySelectorAll<HTMLElement>("[data-stack-item]"),
		);

		// Read pre-computed data from Astro (built at compile time)
		const initialVisible = Number(section.dataset.initialVisible) || 9;
		const totalItems = Number(section.dataset.totalItems) || 0;
		const indicesByCategory: Record<string, number[]> = JSON.parse(
			section.dataset.indices || "{}",
		);

		// Build arrays from pre-computed counts (faster than parsing comma-separated strings)
		const allIndices = Array.from({ length: totalItems }, (_, i) => i);
		const visibleIndices = new Set(
			Array.from({ length: Math.min(initialVisible, totalItems) }, (_, i) => i),
		);

		// State
		const activeCategories = new Set<string>();
		let isExpanded = false;

		function update(): void {
			const hasFilter = activeCategories.size > 0;

			// Get matching indices - no iteration when no filter
			let matchingIndices: number[];
			if (hasFilter) {
				matchingIndices = [];
				for (const cat of activeCategories) {
					const indices = indicesByCategory[cat];
					if (indices) {
						for (const i of indices) matchingIndices.push(i);
					}
				}
				matchingIndices.sort((a, b) => a - b);
			} else {
				matchingIndices = allIndices;
			}

			const totalMatching = matchingIndices.length;
			const limit = isExpanded
				? totalMatching
				: Math.min(initialVisible, totalMatching);

			// Build next visible set from slice (avoids iteration for limit check)
			const nextVisible = new Set(matchingIndices.slice(0, limit));

			// Diff: hide items no longer visible
			for (const i of visibleIndices) {
				if (!nextVisible.has(i)) {
					elements[i].dataset.hidden = "";
				}
			}

			// Diff: show newly visible items
			for (const i of nextVisible) {
				if (!visibleIndices.has(i)) {
					delete elements[i].dataset.hidden;
				}
			}

			// Update state in place
			visibleIndices.clear();
			for (const i of nextVisible) visibleIndices.add(i);

			if (clearBtn) {
				animateClearButton(clearBtn, hasFilter);
			}

			if (viewMoreBtn) {
				updateViewMoreButton(
					viewMoreBtn,
					totalMatching > initialVisible,
					isExpanded,
				);
			}
		}

		// Event delegation for filter chips
		filtersContainer?.addEventListener("click", (e) => {
			const filterBtn = (e.target as HTMLElement).closest<HTMLButtonElement>(
				"[data-stack-filter]",
			);
			if (!filterBtn) return;

			const category = filterBtn.dataset.stackFilter;
			if (!category) return;

			const isPressed = filterBtn.getAttribute("aria-pressed") === "true";
			filterBtn.setAttribute("aria-pressed", String(!isPressed));

			if (isPressed) {
				activeCategories.delete(category);
			} else {
				activeCategories.add(category);
			}

			update();
		});

		// Clear button
		clearBtn?.addEventListener("click", () => {
			activeCategories.clear();
			filters.forEach((f) => f.setAttribute("aria-pressed", "false"));
			update();
		});

		// View more button
		viewMoreBtn?.addEventListener("click", () => {
			isExpanded = !isExpanded;
			update();
		});
	}

	initStackSection();
	document.addEventListener("astro:after-swap", initStackSection);
</script>
