---
import Card from "@/components/Card.astro";
import ClearFilterButton from "@/components/ClearFilterButton.astro";
import FilterChip from "@/components/FilterChip.astro";
import TechItem from "@/components/TechItem.astro";
import ViewMoreButton from "@/components/ViewMoreButton.astro";

type Category = "frameworks" | "languages" | "tools";

interface Technology {
	name: string;
	icon: string;
	experience: number;
	category: Category;
}

interface Props {
	technologies: Technology[];
	initialVisible?: number;
}

const { technologies, initialVisible = 9 } = Astro.props;

const categories: { id: Category; label: string }[] = [
	{ id: "frameworks", label: "Frameworks" },
	{ id: "languages", label: "Languages" },
	{ id: "tools", label: "Tools" },
];
---

<Card>
	<div
		class="flex flex-col gap-6"
		data-stack-section
		data-initial-visible={initialVisible}
	>
		<header
			class="flex flex-col items-start gap-4 sm:flex-row sm:items-center sm:justify-between"
		>
			<h2 class="text-2xl font-semibold text-title">Stack</h2>
			<div class="flex gap-2 items-center">
				<ClearFilterButton class="stack-clear order-1 sm:order-first" />
				{
					categories.map(({ id, label }) => (
						<FilterChip category={id} label={label} class="stack-filter" />
					))
				}
			</div>
		</header>

		<ul
			class="stack-grid grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 list-none p-0 m-0"
			role="list"
		>
			{
				technologies.map((tech, index) => (
					<li
						class:list={["stack-item", { hidden: index >= initialVisible }]}
						data-category={tech.category}
					>
						<TechItem
							name={tech.name}
							icon={tech.icon}
							experience={tech.experience}
						/>
					</li>
				))
			}
		</ul>

		<ViewMoreButton class="stack-view-more" />
	</div>
</Card>

<style>
	.stack-item.hidden,
	.stack-item.filtered {
		display: none;
	}
</style>

<script>
	function initStackSection() {
		const section = document.querySelector(
			"[data-stack-section]",
		) as HTMLElement;
		if (!section) return;

		const initialVisible = parseInt(section.dataset.initialVisible || "9", 10);
		const filters =
			section.querySelectorAll<HTMLButtonElement>(".stack-filter");
		const clearBtn = section.querySelector<HTMLButtonElement>(".stack-clear");
		const items = section.querySelectorAll<HTMLLIElement>(".stack-item");
		const viewMoreBtn =
			section.querySelector<HTMLButtonElement>(".stack-view-more");
		const viewMoreText = viewMoreBtn?.querySelector<HTMLSpanElement>(
			".view-more-btn-text",
		);

		let activeCategories = new Set<string>();
		let isExpanded = false;

		function updateVisibility() {
			let visibleCount = 0;
			let totalVisible = 0;

			items.forEach((item) => {
				const category = item.dataset.category;
				const matchesFilter =
					activeCategories.size === 0 || activeCategories.has(category || "");

				if (!matchesFilter) {
					item.classList.remove("hidden");
					item.classList.add("filtered");
				} else {
					item.classList.remove("filtered");
					totalVisible++;
					visibleCount++;
					const shouldHide = !isExpanded && visibleCount > initialVisible;

					if (shouldHide) {
						item.classList.add("hidden");
					} else {
						item.classList.remove("hidden");
					}
				}
			});

			// Update clear button
			if (clearBtn) {
				const shouldShow = activeCategories.size > 0;
				const isCurrentlyHidden = clearBtn.classList.contains("hidden");

				if (shouldShow && isCurrentlyHidden) {
					clearBtn.classList.remove("hidden", "disappearing");
					clearBtn.classList.add("appearing");
				} else if (!shouldShow && !isCurrentlyHidden) {
					clearBtn.classList.remove("appearing");
					clearBtn.classList.add("disappearing");
					clearBtn.addEventListener(
						"animationend",
						() => {
							if (clearBtn.classList.contains("disappearing")) {
								clearBtn.classList.add("hidden");
							}
						},
						{ once: true },
					);
				}
			}

			// Update view more button
			if (viewMoreBtn && viewMoreText) {
				const hasMore = totalVisible > initialVisible;
				viewMoreBtn.classList.toggle("hidden", !hasMore);
				viewMoreText.textContent = isExpanded
					? viewMoreBtn.dataset.expandedText || "View Less"
					: viewMoreBtn.dataset.collapsedText || "View More";
				viewMoreBtn.classList.toggle("expanded", isExpanded);
			}
		}

		filters.forEach((filter) => {
			filter.addEventListener("click", () => {
				const category = filter.dataset.category;
				if (!category) return;

				const isPressed = filter.getAttribute("aria-pressed") === "true";
				filter.setAttribute("aria-pressed", String(!isPressed));

				if (isPressed) {
					activeCategories.delete(category);
				} else {
					activeCategories.add(category);
				}

				updateVisibility();
			});
		});

		clearBtn?.addEventListener("click", () => {
			activeCategories.clear();
			filters.forEach((filter) => filter.setAttribute("aria-pressed", "false"));
			updateVisibility();
		});

		viewMoreBtn?.addEventListener("click", () => {
			isExpanded = !isExpanded;
			updateVisibility();
		});

		// Initial render
		updateVisibility();
	}

	// Run on initial load
	initStackSection();

	// Re-run on Astro page transitions
	document.addEventListener("astro:after-swap", initStackSection);
</script>
