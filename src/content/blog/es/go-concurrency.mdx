---
title: "Dominando los Patrones de Concurrencia en Go"
description: "Entendiendo goroutines, canales y patrones comunes de concurrencia en Go."
date: 2026-01-02
category: "Go"
tags: ["go", "concurrencia", "goroutines"]
lang: "es"
translationSlug: "go-concurrency"
---

El modelo de concurrencia de Go es una de sus características más fuertes. Exploremos los patrones que lo hacen poderoso.

## Goroutines: Hilos Ligeros

Las goroutines son increíblemente baratas de crear, permitiéndote crear miles sin preocupación.

```go
func main() {
    go processTask("task-1")
    go processTask("task-2")
    go processTask("task-3")

    time.Sleep(time.Second)
}
```

## Canales para Comunicación

Los canales son la forma idiomática de comunicarse entre goroutines.

```go
func worker(jobs <-chan int, results chan<- int) {
    for job := range jobs {
        results <- job * 2
    }
}

func main() {
    jobs := make(chan int, 100)
    results := make(chan int, 100)

    // Iniciar workers
    for w := 1; w <= 3; w++ {
        go worker(jobs, results)
    }

    // Enviar trabajos
    for j := 1; j <= 5; j++ {
        jobs <- j
    }
    close(jobs)
}
```

## La Sentencia Select

Select te permite esperar múltiples operaciones de canal.

```go
select {
case msg := <-ch1:
    fmt.Println("Recibido de ch1:", msg)
case msg := <-ch2:
    fmt.Println("Recibido de ch2:", msg)
case <-time.After(time.Second):
    fmt.Println("Timeout!")
}
```

## Conclusión

Las primitivas de concurrencia de Go son simples pero poderosas. Domínalas para construir sistemas altamente concurrentes.
